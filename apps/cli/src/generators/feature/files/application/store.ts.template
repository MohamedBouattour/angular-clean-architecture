import { signalStore, withState, withMethods, withComputed } from '@ngrx/signals';
import { computed, inject } from '@angular/core';
import { rxMethod } from '@ngrx/signals/rxjs-interop';
import { pipe, tap, switchMap, catchError, of } from 'rxjs';
import { tapResponse } from '@ngrx/operators';
import { <%= pascalName %>Service } from '../infrastructure/service';
import { <%= pascalName %> } from '../domain/model';

interface <%= pascalName %>State {
  items: <%= pascalName %>[];
  loading: boolean;
  error: string | null;
  filter: string;
  sortField: keyof <%= pascalName %>;
  sortDirection: 'asc' | 'desc';
}

export const <%= pascalName %>Store = signalStore(
  { providedIn: 'root' },
  withState<<%= pascalName %>State>({
    items: [],
    loading: false,
    error: null,
    filter: '',
    sortField: 'createdAt',
    sortDirection: 'desc'
  }),
  withComputed((state) => ({
    filteredAndSortedItems: computed(() => {
      let items = [...state.items()];
      
      // Apply filter
      const filter = state.filter().toLowerCase();
      if (filter) {
        items = items.filter(item =>
          Object.values(item).some(val =>
            String(val).toLowerCase().includes(filter)
          )
        );
      }
      
      // Apply sort
      const field = state.sortField();
      const direction = state.sortDirection();
      items.sort((a, b) => {
        const aVal = a[field];
        const bVal = b[field];
        const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
        return direction === 'asc' ? comparison : -comparison;
      });
      
      return items;
    })
  })),
  withMethods((store, service = inject(<%= pascalName %>Service)) => ({
    loadAll: rxMethod<void>(
      pipe(
        tap(() => store.update({ loading: true, error: null })),
        switchMap(() =>
          service.getAll().pipe(
            tapResponse({
              next: (items) => store.update({ items, loading: false }),
              error: (error: Error) =>
                store.update({ error: error.message, loading: false })
            })
          )
        )
      )
    ),
    
    create: rxMethod<Omit<<%= pascalName %>, 'id' | 'createdAt' | 'updatedAt'>>(
      pipe(
        tap(() => store.update({ loading: true, error: null })),
        switchMap((data) =>
          service.create(data).pipe(
            tapResponse({
              next: (item) =>
                store.update((state) => ({
                  items: [...state.items, item],
                  loading: false
                })),
              error: (error: Error) =>
                store.update({ error: error.message, loading: false })
            })
          )
        )
      )
    ),
    
    update: rxMethod<{ id: string; data: Partial<<%= pascalName %>> }>(
      pipe(
        tap(() => store.update({ loading: true, error: null })),
        switchMap(({ id, data }) =>
          service.update(id, data).pipe(
            tapResponse({
              next: (updated) =>
                store.update((state) => ({
                  items: state.items.map((item) =>
                    item.id === id ? updated : item
                  ),
                  loading: false
                })),
              error: (error: Error) =>
                store.update({ error: error.message, loading: false })
            })
          )
        )
      )
    ),
    
    delete: rxMethod<string>(
      pipe(
        tap(() => store.update({ loading: true, error: null })),
        switchMap((id) =>
          service.delete(id).pipe(
            tapResponse({
              next: () =>
                store.update((state) => ({
                  items: state.items.filter((item) => item.id !== id),
                  loading: false
                })),
              error: (error: Error) =>
                store.update({ error: error.message, loading: false })
            })
          )
        )
      )
    ),
    
    setFilter: (filter: string) => store.update({ filter }),
    
    setSort: (field: keyof <%= pascalName %>, direction: 'asc' | 'desc') =>
      store.update({ sortField: field, sortDirection: direction })
  }))
);
